"""Command line interface for marking files for TouchFS content generation.

This module provides a CLI interface that extends the behavior of the `touch` 
command within TouchFS filesystems - marking files to have their content 
generated by TouchFS.

Key Features:
1. Like touch, creates files if they don't exist
2. Sets generate_content xattr to mark files for content generation
3. Extends touch with --parents/-p flag to create parent directories (like mkdir -p)
4. Handles multiple files in a single command
5. Safe operation with confirmation for non-touchfs paths

The command is particularly useful for:
1. Working with files outside a TouchFS mount that will be moved into one
2. Making the content generation intent explicit in scripts/automation
3. Batch marking multiple files for generation
4. Creating files in non-existent directory structures (with --parents)

The command will warn if the target path is not within a TouchFS filesystem,
since the generate_content xattr only has effect within TouchFS mounts.
"""

import sys
import os
import argparse
from typing import Optional, List, Tuple, Dict, Any
from ..config.logger import setup_logging
from ..core.context import build_context

def is_path_in_touchfs(path: str) -> bool:
    """Check if a path is within a mounted touchfs filesystem.
    
    Args:
        path: Path to check
        
    Returns:
        True if path is within a touchfs mount, False otherwise
    """
    # Get absolute path
    abs_path = os.path.abspath(path)
    
    # Walk up directory tree checking for .touchfs marker
    current = abs_path
    while current != '/':
        if os.path.exists(os.path.join(current, '.touchfs')):
            return True
        current = os.path.dirname(current)
    return False

def categorize_paths(paths: List[str]) -> Tuple[List[str], List[str]]:
    """Categorize paths into touchfs and non-touchfs lists.
    
    Args:
        paths: List of paths to categorize
        
    Returns:
        Tuple of (touchfs_paths, non_touchfs_paths)
    """
    touchfs_paths = []
    non_touchfs_paths = []
    
    for path in paths:
        abs_path = os.path.abspath(path)
        if is_path_in_touchfs(abs_path):
            touchfs_paths.append(abs_path)
        else:
            non_touchfs_paths.append(abs_path)
            
    return touchfs_paths, non_touchfs_paths

def create_file_with_xattr(path: str, create_parents: bool = False, context: Optional[str] = None) -> bool:
    """Create a file and set the generate_content xattr.
    
    Args:
        path: Path to file to create and mark
        create_parents: Whether to create parent directories if they don't exist
        context: Optional context string to store in xattr
        
    Returns:
        True if successful, False if error occurred
    """
    try:
        # Handle parent directories
        parent_dir = os.path.dirname(path)
        if parent_dir and not os.path.exists(parent_dir):
            if create_parents:
                os.makedirs(parent_dir)
            else:
                print(f"Error: Parent directory '{parent_dir}' does not exist", file=sys.stderr)
                print("Use --parents/-p to create parent directories", file=sys.stderr)
                return False
            
        # Create file if it doesn't exist
        if not os.path.exists(path):
            with open(path, 'a'):
                pass
                
        try:
            # Set xattrs
            os.setxattr(path, 'touchfs.generate_content', b'true')
            if context:
                os.setxattr(path, 'touchfs.context', context.encode('utf-8'))
            print(f"Successfully marked '{path}' for TouchFS content generation", file=sys.stderr)
            return True
        except OSError as e:
            if e.errno == 95:  # Operation not supported
                # Create file but don't fail if xattrs aren't supported
                print(f"Warning: Extended attributes not supported for '{path}'", file=sys.stderr)
                print(f"Successfully created '{path}' but could not mark for generation", file=sys.stderr)
                return True
            raise
    except OSError as e:
        print(f"Error processing '{path}': {e}", file=sys.stderr)
        return False

def generate_main(files: List[str], force: bool = False, parents: bool = False, debug_stdout: bool = False, max_tokens: Optional[int] = None) -> int:
    """Main entry point for generate command.
    
    This command sets the generate_content xattr that TouchFS uses to identify
    files that should have their content generated. Within a TouchFS filesystem,
    this is automatically set by the touch command - this CLI provides an
    explicit way to set the same marker.
    
    Args:
        files: List of files to mark for generation
        force: Skip confirmation for non-touchfs paths
        parents: Create parent directories as needed
        debug_stdout: Enable debug output to stdout
        max_tokens: Maximum number of tokens to include in context
        
    Returns:
        Exit code (0 for success, 1 for error)
    """
    try:
        # Setup logging
        logger = setup_logging(debug_stdout=debug_stdout)
        logger.debug("==== TouchFS Generate Command Started ====")
        
        # Categorize paths
        touchfs_paths, non_touchfs_paths = categorize_paths(files)
        
        # Early warning about non-touchfs paths
        if non_touchfs_paths:
            print("Warning: The following paths are not within a TouchFS filesystem:", file=sys.stderr)
            for path in non_touchfs_paths:
                print(f"  {path}", file=sys.stderr)
            print("\nNote: The generate_content marker only affects files within TouchFS mounts", file=sys.stderr)
            print("      Using touch within a TouchFS mount automatically sets this marker", file=sys.stderr)
            
            if not force:
                # Prompt for each non-touchfs path
                approved_non_touchfs = []
                for path in non_touchfs_paths:
                    response = input(f"\nDo you want to mark '{path}'? [y/N] ")
                    if response.lower() == 'y':
                        approved_non_touchfs.append(path)
                    
                if not approved_non_touchfs and not touchfs_paths:
                    print("No paths approved for marking", file=sys.stderr)
                    return 0
                    
                non_touchfs_paths = approved_non_touchfs
        
        # Prompt for touchfs paths if any exist and we have approvals/force
        if touchfs_paths and (force or non_touchfs_paths or not len(files) == len(touchfs_paths)):
            print("\nThe following paths will be marked for generation:", file=sys.stderr)
            for path in touchfs_paths:
                print(f"  {path}", file=sys.stderr)
            response = input("\nDo you want to continue? [Y/n] ")
            if response.lower() == 'n':
                print("No paths approved for marking", file=sys.stderr)
                return 0
        
        # Build context from approved paths' directory
        all_paths = non_touchfs_paths + touchfs_paths
        if all_paths:
            # Use parent directory of first path as context root
            context_root = os.path.dirname(all_paths[0])
            try:
                context = build_context(context_root, max_tokens=max_tokens)
            except Exception as e:
                logger.warning(f"Failed to build context: {e}")
                context = None
        else:
            context = None

        # Process all approved paths
        had_error = False
        for path in all_paths:
            if not create_file_with_xattr(path, create_parents=parents, context=context):
                had_error = True
                
        if not had_error:
            print("(This is equivalent to using touch within a TouchFS filesystem)", file=sys.stderr)
            
        # Return 0 even if some paths failed, like touch does
        return 0
            
    except Exception as e:
        if debug_stdout:
            print(f"Error in generate command: {e}", file=sys.stderr)
        return 0  # Still return 0 like touch

def add_generate_parser(subparsers):
    """Add generate-related parsers to the CLI argument parser."""
    # Generate subcommand
    generate_parser = subparsers.add_parser(
        'generate',
        help='Mark files for content generation',
        description='Mark files for TouchFS content generation',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    generate_parser.add_argument(
        'files',
        nargs='+',
        help='Files to mark for generation'
    )
    generate_parser.add_argument(
        '-p', '--parents',
        action='store_true',
        help='Create parent directories if needed'
    )
    generate_parser.add_argument(
        '-f', '--force',
        action='store_true',
        help='Skip confirmation for non-touchfs paths'
    )
    generate_parser.add_argument(
        '--debug-stdout',
        action='store_true',
        help='Enable debug output'
    )
    generate_parser.add_argument(
        '-m', '--max-tokens',
        type=int,
        help='Maximum number of tokens to include in context'
    )
    generate_parser.set_defaults(func=lambda args: sys.exit(generate_main(
        files=args.files,
        force=args.force,
        parents=args.parents,
        debug_stdout=args.debug_stdout,
        max_tokens=args.max_tokens
    )))
    
    return generate_parser

def run(args=None):
    """Entry point for the command-line script."""
    if args is None:
        parser = argparse.ArgumentParser()
        add_generate_parser(parser.add_subparsers())
        args = parser.parse_args()
    sys.exit(generate_main(
        files=args.files,
        force=args.force,
        parents=args.parents,
        debug_stdout=args.debug_stdout,
        max_tokens=getattr(args, 'max_tokens', None)
    ))
