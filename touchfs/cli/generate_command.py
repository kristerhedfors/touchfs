"""Command line interface for marking files for TouchFS content generation.

This module provides a CLI interface that extends the behavior of the `touch` 
command within TouchFS filesystems - marking files to have their content 
generated by TouchFS.

Key Features:
1. Like touch, creates files if they don't exist
2. Sets generate_content xattr to mark files for content generation
3. Extends touch with --parents/-p flag to create parent directories (like mkdir -p)
4. Handles multiple files in a single command
5. Safe operation with confirmation for non-touchfs paths

The command is particularly useful for:
1. Working with files outside a TouchFS mount that will be moved into one
2. Making the content generation intent explicit in scripts/automation
3. Batch marking multiple files for generation
4. Creating files in non-existent directory structures (with --parents)

The command will warn if the target path is not within a TouchFS filesystem,
since the generate_content xattr only has effect within TouchFS mounts.
"""

import sys
import os
import argparse
from typing import Optional, List, Tuple, Dict, Any
from ..config.logger import setup_logging
from ..core.context import build_context

def is_path_in_touchfs(path: str, logger=None) -> bool:
    """Check if a path is within a mounted touchfs filesystem.
    
    Args:
        path: Path to check
        
    Returns:
        True if path is within a touchfs mount, False otherwise
    """
    try:
        # Get absolute path and resolve any symlinks
        abs_path = os.path.realpath(path)
        if logger:
            logger.debug(f"Checking if path is in touchfs: {abs_path}")
        
        # Walk up directory tree checking for .touchfs marker
        current = abs_path
        while current != '/':
            marker_path = os.path.join(current, '.touchfs')
            if logger:
                logger.debug(f"Checking for marker at: {marker_path}")
            if os.path.exists(marker_path):
                if logger:
                    logger.debug(f"Found touchfs marker at: {marker_path}")
                return True
            parent = os.path.dirname(current)
            if parent == current:  # Handle root directory case
                if logger:
                    logger.debug("Reached root directory")
                break
            current = parent
            
        # Also check the root directory
        root_marker = os.path.join('/', '.touchfs')
        if logger:
            logger.debug(f"Checking root marker: {root_marker}")
        if os.path.exists(root_marker):
            if logger:
                logger.debug("Found touchfs marker in root directory")
            return True
            
        if logger:
            logger.debug("No touchfs marker found")
        return False
    except Exception as e:
        print(f"Warning: Error checking if path is in touchfs: {e}", file=sys.stderr)
        return False

def categorize_paths(paths: List[str], logger=None) -> Tuple[List[str], List[str]]:
    """Categorize paths into touchfs and non-touchfs lists.
    
    Args:
        paths: List of paths to categorize
        logger: Optional logger for debug output
        
    Returns:
        Tuple of (touchfs_paths, non_touchfs_paths)
    """
    touchfs_paths = []
    non_touchfs_paths = []
    
    for path in paths:
        abs_path = os.path.abspath(path)
        if logger:
            logger.debug(f"Checking path: {abs_path}")
            
        if is_path_in_touchfs(abs_path, logger=logger):
            if logger:
                logger.debug(f"Path is in touchfs: {abs_path}")
            touchfs_paths.append(abs_path)
        else:
            if logger:
                logger.debug(f"Path is not in touchfs: {abs_path}")
            non_touchfs_paths.append(abs_path)
            
    if logger:
        logger.debug(f"TouchFS paths: {touchfs_paths}")
        logger.debug(f"Non-TouchFS paths: {non_touchfs_paths}")
            
    return touchfs_paths, non_touchfs_paths


def create_file_with_xattr(path: str, create_parents: bool = False, context: Optional[str] = None, logger=None) -> bool:
    """Create a file and set the generate_content xattr.
    
    Args:
        path: Path to file to create and mark
        create_parents: Whether to create parent directories if they don't exist
        context: Optional context string to store in xattr
        
    Returns:
        True if successful, False if error occurred
    """
    try:
        # Handle parent directories
        parent_dir = os.path.dirname(path)
        if parent_dir and not os.path.exists(parent_dir):
            if create_parents:
                os.makedirs(parent_dir)
            else:
                print(f"Error: Parent directory '{parent_dir}' does not exist", file=sys.stderr)
                print("Use --parents/-p to create parent directories", file=sys.stderr)
                return False
            
        # Create file if it doesn't exist
        try:
            if not os.path.exists(path):
                logger.debug(f"Creating file: {path}")
                with open(path, 'w') as f:
                    f.write('')  # Explicitly write empty content
                logger.debug(f"File created successfully: {path}")
                
            # Set xattrs
            logger.debug(f"Setting xattrs for: {path}")
            os.setxattr(path, 'touchfs.generate_content', b'true')
            if context:
                os.setxattr(path, 'touchfs.context', context.encode('utf-8'))
            logger.debug(f"Xattrs set successfully for: {path}")
            print(f"Successfully marked '{path}' for TouchFS content generation", file=sys.stderr)
            return True
        except OSError as e:
            if e.errno == 95:  # Operation not supported
                # Create file but don't fail if xattrs aren't supported
                print(f"Warning: Extended attributes not supported for '{path}'", file=sys.stderr)
                print(f"Successfully created '{path}' but could not mark for generation", file=sys.stderr)
                return True
            raise
    except OSError as e:
        print(f"Error processing '{path}': {e}", file=sys.stderr)
        return False

def generate_main(files: List[str], force: bool = False, parents: bool = False, debug_stdout: bool = False, max_tokens: Optional[int] = None) -> int:
    """Main entry point for generate command.
    
    This command sets the generate_content xattr that TouchFS uses to identify
    files that should have their content generated. Within a TouchFS filesystem,
    this is automatically set by the touch command - this CLI provides an
    explicit way to set the same marker.
    
    Args:
        files: List of files to mark for generation
        force: Skip confirmation for non-touchfs paths
        parents: Create parent directories as needed
        debug_stdout: Enable debug output to stdout
        max_tokens: Maximum number of tokens to include in context
        
    Returns:
        Exit code (0 for success, 1 for error)
    """
    try:
        # Setup logging
        logger = setup_logging(debug_stdout=debug_stdout)
        logger.debug("==== TouchFS Generate Command Started ====")
        
        # Categorize paths
        touchfs_paths, non_touchfs_paths = categorize_paths(files, logger=logger)
        
        # Warn about non-touchfs paths but proceed without confirmation
        if non_touchfs_paths:
            print("Warning: The following paths are not within a TouchFS filesystem (no parent directory contains a .touchfs folder):", file=sys.stderr)
            for path in non_touchfs_paths:
                print(f"  {path}", file=sys.stderr)
        
        # Prompt for touchfs paths if any exist and we're not forcing
        if touchfs_paths and not force:
            print("\nThe following paths will be marked for generation:", file=sys.stderr)
            for path in touchfs_paths:
                print(f"  {path}", file=sys.stderr)
            response = input("\nDo you want to continue? [Y/n] ")
            if response.lower() == 'n':
                print("No paths approved for marking", file=sys.stderr)
                return 0
        
        # Build context from approved paths' directory
        all_paths = non_touchfs_paths + touchfs_paths
        if all_paths:
            # Use parent directory of first path as context root
            context_root = os.path.dirname(all_paths[0])
            try:
                context = build_context(context_root, max_tokens=max_tokens)
            except Exception as e:
                logger.warning(f"Failed to build context: {e}")
                context = None
        else:
            context = None

        # Process all approved paths
        had_error = False
        for path in all_paths:
            if not create_file_with_xattr(path, create_parents=parents, context=context, logger=logger):
                had_error = True
                
        if not had_error:
            print("(This is equivalent to using touch within a TouchFS filesystem)", file=sys.stderr)
            
        # Return 0 even if some paths failed, like touch does
        return 0
            
    except Exception as e:
        if debug_stdout:
            print(f"Error in generate command: {e}", file=sys.stderr)
        return 0  # Still return 0 like touch

def add_generate_parser(subparsers):
    """Add generate-related parsers to the CLI argument parser."""
    # Generate subcommand
    generate_parser = subparsers.add_parser(
        'generate',
        help='Mark files for content generation',
        description='Mark files for TouchFS content generation',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    generate_parser.add_argument(
        'files',
        nargs='+',
        help='Files to mark for generation'
    )
    generate_parser.add_argument(
        '-p', '--parents',
        action='store_true',
        help='Create parent directories if needed'
    )
    generate_parser.add_argument(
        '-f', '--force',
        action='store_true',
        help='Skip confirmation for non-touchfs paths'
    )
    generate_parser.add_argument(
        '--debug-stdout',
        action='store_true',
        help='Enable debug output'
    )
    generate_parser.add_argument(
        '-m', '--max-tokens',
        type=int,
        help='Maximum number of tokens to include in context'
    )
    generate_parser.set_defaults(func=lambda args: sys.exit(generate_main(
        files=args.files,
        force=args.force,
        parents=args.parents,
        debug_stdout=args.debug_stdout,
        max_tokens=args.max_tokens
    )))
    
    return generate_parser

def run(args=None):
    """Entry point for the command-line script."""
    if args is None:
        parser = argparse.ArgumentParser()
        add_generate_parser(parser.add_subparsers())
        args = parser.parse_args()
    sys.exit(generate_main(
        files=args.files,
        force=args.force,
        parents=args.parents,
        debug_stdout=args.debug_stdout,
        max_tokens=getattr(args, 'max_tokens', None)
    ))
