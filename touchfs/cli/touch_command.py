"""Command line interface for marking files for TouchFS content generation.

This module provides a CLI interface that extends the behavior of the `touch` 
command within TouchFS filesystems - marking files to have their content 
generated by TouchFS.

Key Features:
1. Like touch, creates files if they don't exist
2. Sets generate_content xattr to mark files for content generation
3. Extends touch with --parents/-p flag to create parent directories (like mkdir -p)
4. Handles multiple files in a single command
5. Safe operation with confirmation for non-touchfs paths

The command is particularly useful for:
1. Working with files outside a TouchFS mount that will be moved into one
2. Making the content generation intent explicit in scripts/automation
3. Batch marking multiple files for generation
4. Creating files in non-existent directory structures (with --parents)

The command will warn if the target path is not within a TouchFS filesystem,
since the generate_content xattr only has effect within TouchFS mounts.
"""

import sys
import os
import argparse
import curses
from typing import Optional, List, Tuple, Dict, Any, Set
from openai import OpenAI
from ..config.logger import setup_logging
from ..core.context import build_context
from ..config import templates, model
from ..models.filename_suggestions import FilenameSuggestions

def get_openai_client() -> OpenAI:
    """Initialize OpenAI client with API key from environment."""
    api_key = model.get_openai_key()
    return OpenAI(api_key=api_key)

def is_path_in_touchfs(path: str, logger=None) -> bool:
    """Check if a path is within a mounted touchfs filesystem.
    
    Args:
        path: Path to check
        
    Returns:
        True if path is within a touchfs mount, False otherwise
    """
    try:
        # Get absolute path and resolve any symlinks
        abs_path = os.path.realpath(path)
        if logger:
            logger.debug(f"Checking if path is in touchfs: {abs_path}")
        
        # Walk up directory tree checking for .touchfs marker
        current = abs_path
        while current != '/':
            marker_path = os.path.join(current, '.touchfs')
            if logger:
                logger.debug(f"Checking for marker at: {marker_path}")
            if os.path.exists(marker_path):
                if logger:
                    logger.debug(f"Found touchfs marker at: {marker_path}")
                return True
            parent = os.path.dirname(current)
            if parent == current:  # Handle root directory case
                if logger:
                    logger.debug("Reached root directory")
                break
            current = parent
            
        # Also check the root directory
        root_marker = os.path.join('/', '.touchfs')
        if logger:
            logger.debug(f"Checking root marker: {root_marker}")
        if os.path.exists(root_marker):
            if logger:
                logger.debug("Found touchfs marker in root directory")
            return True
            
        if logger:
            logger.debug("No touchfs marker found")
        return False
    except Exception as e:
        print(f"Warning: Error checking if path is in touchfs: {e}", file=sys.stderr)
        return False

def categorize_paths(paths: List[str], logger=None) -> Tuple[List[str], List[str]]:
    """Categorize paths into touchfs and non-touchfs lists.
    
    Args:
        paths: List of paths to categorize
        logger: Optional logger for debug output
        
    Returns:
        Tuple of (touchfs_paths, non_touchfs_paths)
    """
    touchfs_paths = []
    non_touchfs_paths = []
    
    for path in paths:
        abs_path = os.path.abspath(path)
        if logger:
            logger.debug(f"Checking path: {abs_path}")
            
        if is_path_in_touchfs(abs_path, logger=logger):
            if logger:
                logger.debug(f"Path is in touchfs: {abs_path}")
            touchfs_paths.append(abs_path)
        else:
            if logger:
                logger.debug(f"Path is not in touchfs: {abs_path}")
            non_touchfs_paths.append(abs_path)
            
    if logger:
        logger.debug(f"TouchFS paths: {touchfs_paths}")
        logger.debug(f"Non-TouchFS paths: {non_touchfs_paths}")
            
    return touchfs_paths, non_touchfs_paths


def create_file_with_xattr(path: str, create_parents: bool = False, context: Optional[str] = None, logger=None) -> bool:
    """Create a file and set the generate_content xattr.
    
    Args:
        path: Path to file to create and mark
        create_parents: Whether to create parent directories if they don't exist
        context: Optional context string to store in xattr
        
    Returns:
        True if successful, False if error occurred
    """
    try:
        # Handle parent directories
        parent_dir = os.path.dirname(path)
        if parent_dir and not os.path.exists(parent_dir):
            if create_parents:
                os.makedirs(parent_dir)
            else:
                print(f"Error: Parent directory '{parent_dir}' does not exist", file=sys.stderr)
                print("Use --parents/-p to create parent directories", file=sys.stderr)
                return False
            
        # Create file if it doesn't exist
        try:
            if not os.path.exists(path):
                logger.debug(f"Creating file: {path}")
                with open(path, 'w') as f:
                    f.write('')  # Explicitly write empty content
                logger.debug(f"File created successfully: {path}")
                
            # Set xattrs
            logger.debug(f"Setting xattrs for: {path}")
            os.setxattr(path, 'touchfs.generate_content', b'true')
            if context:
                os.setxattr(path, 'touchfs.context', context.encode('utf-8'))
            logger.debug(f"Xattrs set successfully for: {path}")
            print(f"Successfully marked '{path}' for TouchFS content generation", file=sys.stderr)
            return True
        except OSError as e:
            if e.errno == 95:  # Operation not supported
                # Create file but don't fail if xattrs aren't supported
                print(f"Warning: Extended attributes not supported for '{path}'", file=sys.stderr)
                print(f"Successfully created '{path}' but could not mark for generation", file=sys.stderr)
                return True
            raise
    except OSError as e:
        print(f"Error processing '{path}': {e}", file=sys.stderr)
        return False

def generate_filename_suggestions(directory: str, selected_filenames: Optional[List[str]] = None, max_tokens: Optional[int] = None, logger=None) -> List[str]:
    """Generate filename suggestions based on directory context.
    
    Args:
        directory: Directory to analyze for context
        selected_indices: Optional set of indices from previous suggestions to inform new suggestions
        max_tokens: Maximum tokens for context building
        logger: Optional logger for debug output
        
    Returns:
        List of 10 filename suggestions
    """
    try:
        # Build context from directory
        context = build_context(directory, max_tokens=max_tokens)
        
        # Get system prompt template
        system_prompt = templates.read_template(templates.FILENAME_SUGGESTIONS_SYSTEM_PROMPT_TEMPLATE)
        
        # Format prompt with context and selected files
        final_prompt = system_prompt.format(
            context=context,
            selected_files="\n".join(selected_filenames) if selected_filenames else "None"
        )
        
        # Initialize OpenAI client
        client = get_openai_client()
        
        # Get suggestions from OpenAI
        messages = [
            {"role": "system", "content": final_prompt},
            {"role": "user", "content": f"Suggest {10 if not selected_filenames else 10 - len(selected_filenames)} filenames"}
        ]
        
        try:
            completion = client.beta.chat.completions.parse(
                model=model.get_model(),  # Use default model from settings
                messages=messages,
                response_format=FilenameSuggestions,
                temperature=0.7  # Higher temperature for more diverse suggestions
            )
            
            suggestions = completion.choices[0].message.parsed.filenames
            
            # Add back selected filenames if any
            if selected_filenames:
                suggestions = selected_filenames + suggestions
                
            # Filter out existing files
            dir_contents = os.listdir(directory)
            existing_files = {f for f in dir_contents if os.path.isfile(os.path.join(directory, f))}
            suggestions = [s for s in suggestions if s not in existing_files]
            
            # Ensure we have exactly 10 suggestions
            while len(suggestions) < 10:
                suggestions.append(f"file_{len(suggestions)+1}.txt")
                
            return suggestions[:10]
            
        except Exception as api_error:
            if logger:
                logger.error(f"OpenAI API error: {str(api_error)}")
            raise
            
    except Exception as e:
        if logger:
            logger.error(f"Error generating filename suggestions: {e}")
        return [f"file_{i+1}.txt" for i in range(10)]

def display_menu(suggestions: List[str], allow_multiple: bool = True) -> Tuple[Optional[List[int]], bool]:
    """Display interactive menu for filename selection.
    
    Args:
        suggestions: List of filename suggestions
        allow_multiple: Whether to allow selecting multiple items
        
    Returns:
        List of selected indices, or None if cancelled
    """
    def setup_curses():
        curses.curs_set(0)  # Hide cursor
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)  # Selected item
        
    def draw_menu(stdscr, suggestions: List[str], selected: Set[int], current: int):
        stdscr.clear()
        height, width = stdscr.getmaxyx()
        
        # Draw header
        header = "Select filename(s) - Press SPACE to select, ENTER to confirm, ESC to cancel, r to regenerate"
        if allow_multiple:
            header += " | Multiple selections allowed | Press r to keep selected and regenerate others"
        stdscr.addstr(0, 0, header[:width-1])
        
        # Draw suggestions
        for i, name in enumerate(suggestions):
            if i >= height - 3:  # Leave room for header and footer
                break
                
            style = curses.color_pair(1) if i == current else curses.A_NORMAL
            if i in selected:
                name = f"[*] {name}"
            else:
                name = f"[ ] {name}"
            
            stdscr.addstr(i + 2, 2, name[:width-3], style)
            
        stdscr.refresh()
    
    def menu_loop(stdscr) -> Tuple[Optional[List[int]], bool]:
        setup_curses()
        current = 0
        selected = set()
        
        while True:
            draw_menu(stdscr, suggestions, selected, current)
            key = stdscr.getch()
            
            if key == 27:  # ESC
                return None, False
            elif key == ord('\n'):  # Enter
                if not allow_multiple and not selected:
                    selected.add(current)
                return list(selected) if selected else None, False
            elif key == ord('r'):  # 'r' to regenerate non-selected
                if selected:  # Only allow regeneration if something is selected
                    return list(selected), True
            elif key == ord(' '):  # Space
                if allow_multiple:
                    if current in selected:
                        selected.remove(current)
                    else:
                        selected.add(current)
                else:
                    selected = {current}
            elif key == curses.KEY_UP and current > 0:
                current -= 1
            elif key == curses.KEY_DOWN and current < len(suggestions) - 1:
                current += 1
    
    try:
        return curses.wrapper(menu_loop)
    except Exception:
        return None, False

def touch_main(files: List[str], force: bool = False, parents: bool = False, debug_stdout: bool = False, max_tokens: Optional[int] = None) -> int:
    """Main entry point for touch command.
    
    This command sets the generate_content xattr that TouchFS uses to identify
    files that should have their content generated. Within a TouchFS filesystem,
    this is automatically set by the touch command - this CLI provides an
    explicit way to set the same marker.
    
    Args:
        files: List of files to mark for generation
        force: Skip confirmation for non-touchfs paths
        parents: Create parent directories as needed
        debug_stdout: Enable debug output to stdout
        max_tokens: Maximum number of tokens to include in context
        
    Returns:
        Exit code (0 for success, 1 for error)
    """
    try:
        # Setup logging
        logger = setup_logging(debug_stdout=debug_stdout)
        logger.debug("==== TouchFS Touch Command Started ====")
        
        # Handle directory-only arguments
        if len(files) == 1 and os.path.isdir(files[0]):
            directory = files[0]
            logger.debug(f"Directory-only argument detected: {directory}")
            
            selected_filenames = []
            while True:
                # Generate suggestions based on previous selection
                suggestions = generate_filename_suggestions(
                    directory,
                    selected_filenames=selected_filenames,
                    max_tokens=max_tokens,
                    logger=logger
                )
                
                # Display menu and get selection
                selected, regenerate = display_menu(suggestions, allow_multiple=True)
                if selected is None:
                    logger.debug("User cancelled selection")
                    return 0
                    
                if len(selected) == 0:
                    logger.debug("No selection made")
                    return 0
                
                # Get selected filenames
                selected_filenames = [suggestions[i] for i in selected]
                
                # If not regenerating, create selected files
                if not regenerate:
                    files = [os.path.join(directory, f) for f in selected_filenames]
                    break
                
                # Otherwise continue with new suggestions while keeping selected files
                continue
        
        # Categorize paths
        touchfs_paths, non_touchfs_paths = categorize_paths(files, logger=logger)
        
        # Warn about non-touchfs paths but proceed without confirmation
        if non_touchfs_paths:
            print("Warning: The following paths are not within a TouchFS filesystem (no parent directory contains a .touchfs folder):", file=sys.stderr)
            for path in non_touchfs_paths:
                print(f"  {path}", file=sys.stderr)
        
        # Prompt for touchfs paths if any exist and we're not forcing
        if touchfs_paths and not force:
            print("\nThe following paths will be marked for generation:", file=sys.stderr)
            for path in touchfs_paths:
                print(f"  {path}", file=sys.stderr)
            response = input("\nDo you want to continue? [Y/n] ")
            if response.lower() == 'n':
                print("No paths approved for marking", file=sys.stderr)
                return 0
        
        # Build context from approved paths' directory
        all_paths = non_touchfs_paths + touchfs_paths
        if all_paths:
            # Use parent directory of first path as context root
            context_root = os.path.dirname(all_paths[0])
            try:
                context = build_context(context_root, max_tokens=max_tokens)
            except Exception as e:
                logger.warning(f"Failed to build context: {e}")
                context = None
        else:
            context = None

        # Process all approved paths
        had_error = False
        for path in all_paths:
            if not create_file_with_xattr(path, create_parents=parents, context=context, logger=logger):
                had_error = True
                
        if not had_error:
            print("(This is equivalent to using touch within a TouchFS filesystem)", file=sys.stderr)
            
        # Return 0 even if some paths failed, like touch does
        return 0
            
    except Exception as e:
        if debug_stdout:
            print(f"Error in touch command: {e}", file=sys.stderr)
        return 0  # Still return 0 like touch

def add_touch_parser(subparsers):
    """Add touch-related parsers to the CLI argument parser."""
    # Touch subcommand
    touch_parser = subparsers.add_parser(
        'touch',
        help='Mark files for content generation',
        description='Mark files for TouchFS content generation',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    touch_parser.add_argument(
        'files',
        nargs='+',
        help='Files to mark for generation'
    )
    touch_parser.add_argument(
        '-p', '--parents',
        action='store_true',
        help='Create parent directories if needed'
    )
    touch_parser.add_argument(
        '-f', '--force',
        action='store_true',
        help='Skip confirmation for non-touchfs paths'
    )
    touch_parser.add_argument(
        '--debug-stdout',
        action='store_true',
        help='Enable debug output'
    )
    touch_parser.add_argument(
        '-m', '--max-tokens',
        type=int,
        help='Maximum number of tokens to include in context'
    )
    touch_parser.set_defaults(func=lambda args: sys.exit(touch_main(
        files=args.files,
        force=args.force,
        parents=args.parents,
        debug_stdout=args.debug_stdout,
        max_tokens=args.max_tokens
    )))
    
    return touch_parser

def run(args=None):
    """Entry point for the command-line script."""
    if args is None:
        parser = argparse.ArgumentParser()
        add_touch_parser(parser.add_subparsers())
        args = parser.parse_args()
    sys.exit(touch_main(
        files=args.files,
        force=args.force,
        parents=args.parents,
        debug_stdout=args.debug_stdout,
        max_tokens=getattr(args, 'max_tokens', None)
    ))
